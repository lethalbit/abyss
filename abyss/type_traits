/* SPDX-License-Identifier: BSD-3-Clause */
#pragma once
#if !defined(ABYSS_TYPE_TRAITS)
#define ABYSS_TYPE_TRAITS

#include <abyss/cosmogony/fundamental.hh>
#include <abyss/cosmogony/compiler_support.hh>
#include <abyss/cosmogony/library_config.hh>

__ABYSS_SYSTEM_HEADER()

// Silly clang-tidy, we're the ones defining the traits
// NOLINTBEGIN(modernize-type-traits)
namespace std {

	template<typename _T>
	struct type_identity {
		using type = _T;
	};
	template<typename _T>
	using type_identity_t = type_identity<_T>::type;

	template<typename...>
	using void_t = void;

	template<typename _T, _T _value>
	struct integral_constant {
		static constexpr _T value = _value;
		using value_type = _T;
		using type = integral_constant;
		[[nodiscard]]
		constexpr operator value_type() const noexcept { return value; }
		[[nodiscard]]
		constexpr value_type operator()() const noexcept { return value; }
	};

	template<bool _BVal>
	using bool_constant = integral_constant<bool, _BVal>;

	using true_type  = bool_constant<true>;
	using false_type = bool_constant<false>;

	template<typename _Tl, typename _Tr>
	struct is_same : false_type {};
	template<typename _Ty>
	struct is_same<_Ty, _Ty> : true_type {};
	template<typename _Tl, typename _Tr>
	inline constexpr bool is_same_v = is_same<_Tl, _Tr>::value;

	template<bool _BVal, typename _Ty = void>
	struct enable_if{};
	template<typename _Ty>
	struct enable_if<true, _Ty> { using type = _Ty; };
	template<bool _BVal, typename _Ty = void>
	using enable_if_t = enable_if<_BVal, _Ty>::type;


	template<bool _Bval, typename _True, typename _False>
	struct conditional { using type = _True; };
	template<typename _True, typename _False>
	struct conditional<false, _True, _False> { using type = _False; };
	template<bool _Bval, typename _True, typename _False>
	using conditional_t = conditional<_Bval, _True, _False>::type;

	/* TODO(aki): Needs to be made more robust */
	template<typename...>
	struct conjunction : true_type {};
	template<typename _Ty>
	struct conjunction<_Ty> : _Ty {};
	template<typename _Ty, typename... _Tn>
	struct conjunction<_Ty, _Tn...> : conditional_t<bool(_Ty::value), conjunction<_Tn...>, _Ty> {};
	template<typename... _Ty>
	inline constexpr bool conjunction_v = conjunction<_Ty...>::value;

	/* TODO(aki): Needs to be made more robust */
	template<typename...>
	struct disjunction : false_type {};
	template<typename _Ty>
	struct disjunction<_Ty> : _Ty {};
	template<typename _Ty, typename... _Tn>
	struct disjunction<_Ty, _Tn...> : conditional_t<bool(_Ty::value), _Ty, disjunction<_Tn...>> {};
	template<typename... _Ty>
	inline constexpr bool disjunction_v = disjunction<_Ty...>::value;

	template<typename _Ty>
	struct negation : bool_constant<!bool(_Ty::value)> {};
	template<typename _Ty>
	inline constexpr bool negation_v = negation<_Ty>::value;

	template<typename _Ty>
	struct remove_cv { using type = _Ty; };
	template<typename _Ty>
	struct remove_cv<const _Ty> { using type = _Ty; };
	template<typename _Ty>
	struct remove_cv<volatile _Ty> { using type = _Ty; };
	template<typename _Ty>
	struct remove_cv<const volatile _Ty> { using type = _Ty; };
	template<typename _Ty>
	using remove_cv_t = remove_cv<_Ty>::type;

	template<typename _Ty>
	struct remove_const { using type = _Ty; };
	template<typename _Ty>
	struct remove_const<const _Ty> { using type = _Ty; };
	template<typename _Ty>
	using remove_const_t = remove_const<_Ty>::type;

	template<typename _Ty>
	struct remove_volatile { using type = _Ty; };
	template<typename _Ty>
	struct remove_volatile<volatile _Ty> { using type = _Ty; };
	template<typename _Ty>
	using remove_volatile_t = remove_volatile<_Ty>::type;

	template<typename _Ty>
	struct add_cv { using type = const volatile _Ty; };
	template<typename _Ty>
	using add_cv_t = add_cv<_Ty>::type;

	template<typename _Ty>
	struct add_const { using type = const _Ty; };
	template<typename _Ty>
	using add_const_t = add_const<_Ty>::type;

	template<typename _Ty>
	struct add_volatile { using type = volatile _Ty; };
	template<typename _Ty>
	using add_volatile_t = add_volatile<_Ty>::type;


	template<typename _Ty>
	struct is_const : false_type {};
	template<typename _Ty>
	struct is_const<const _Ty> : true_type {};
	template<typename _Ty>
	inline constexpr bool is_const_v = is_const<_Ty>::value;

	template<typename _Ty>
	struct is_volatile : false_type {};
	template<typename _Ty>
	struct is_volatile<volatile _Ty> : true_type {};
	template<typename _Ty>
	inline constexpr bool is_volatile_v = is_volatile<_Ty>::value;

	namespace _impl {
		template<typename _Ty, bool _Const, bool _Volatile>
		struct _try_match_cv;

		template<typename _Ty>
		struct _try_match_cv<_Ty, false, false> : type_identity<_Ty> {};
		template<typename _Ty>
		struct _try_match_cv<_Ty, false, true> : type_identity<volatile _Ty> {};
		template<typename _Ty>
		struct _try_match_cv<_Ty, true, false> : type_identity<const _Ty> {};
		template<typename _Ty>
		struct _try_match_cv<_Ty, true, true> : type_identity<const volatile _Ty> {};

		template<
			typename _Ty, typename _Uy, bool _Const = std::is_const_v<_Ty>, bool _Volatile = std::is_volatile_v<_Ty>
		>
		struct _match_cv : _try_match_cv<_Uy, _Const, _Volatile> {};
	}

#if defined(ABYSS_EXTRA)
	template<typename _Ty, typename _Uy>
	struct copy_cv : _impl::_match_cv<_Ty, _Uy> {};

	template<typename _Ty, typename _Uy>
	using copy_cv_t = copy_cv<_Ty, _Uy>::type;
#endif

	template<typename _Ty>
	struct remove_reference { using type = _Ty; };
	template<typename _Ty>
	struct remove_reference<_Ty&> { using type = _Ty; };
	template<typename _Ty>
	struct remove_reference<_Ty&&> { using type = _Ty; };
	template<typename _Ty>
	using remove_reference_t = remove_reference<_Ty>::type;

	namespace _impl {
		template<typename _Ty>
		auto _try_add_lvalue_reference(int) -> type_identity<_Ty&>;
		template<typename _Ty>
		auto _try_add_lvalue_reference(...) -> type_identity<_Ty>;

		template<typename _Ty>
		auto _try_add_rvalue_reference(int) -> type_identity<_Ty&&>;
		template<typename _Ty>
		auto _try_add_rvalue_reference(...) -> type_identity<_Ty>;
	}

	template<typename _Ty>
	struct add_lvalue_reference : decltype(_impl::_try_add_lvalue_reference<_Ty>(0)) {};
	template<typename _Ty>
	using add_lvalue_reference_t = add_lvalue_reference<_Ty>::type;

	template<typename _Ty>
	struct add_rvalue_reference : decltype(_impl::_try_add_rvalue_reference<_Ty>(0)) {};
	template<typename _Ty>
	using add_rvalue_reference_t = add_rvalue_reference<_Ty>::type;


	namespace _impl {
		template<typename _Ty>
		add_rvalue_reference_t<_Ty> declval() noexcept {
			static_assert(false, "declval is not allowed in an evaluated context");
		}
	}

	template<typename _Ty>
	struct remove_cvref : type_identity<remove_cv_t<remove_reference_t<_Ty>>> {};
	template<typename _Ty>
	using remove_cvref_t = remove_cvref<_Ty>::type;

	template<typename _Ty>
	struct remove_pointer { using type = _Ty; };
	template<typename _Ty>
	struct remove_pointer<_Ty*> { using type = _Ty; };
	template<typename _Ty>
	struct remove_pointer<_Ty* const> { using type = _Ty; };
	template<typename _Ty>
	struct remove_pointer<_Ty* volatile> { using type = _Ty; };
	template<typename _Ty>
	struct remove_pointer<_Ty* const volatile> { using type = _Ty; };
	template<typename _Ty>
	using remove_pointer_t = remove_pointer<_Ty>::type;

	namespace _impl {
		template<typename _Ty>
		auto _try_add_pointer(int) -> type_identity<remove_reference_t<_Ty>*>;
		template<typename _Ty>
		auto _try_add_pointer(...) -> type_identity<_Ty>;
	};

	template<typename _Ty>
	struct add_pointer: decltype(_impl::_try_add_pointer<_Ty>(0)) {};
	template<typename _Ty>
	using add_pointer_t = add_pointer<_Ty>::type;


	template<typename _Ty>
	struct is_void : is_same<void, remove_cv_t<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_void_v = is_void<_Ty>::value;

	/* NOTE(aki): We use `decltype(nullptr)` here because afaict we can't include <cstddef>  */
	template<typename _Ty>
	struct is_null_pointer : is_same<decltype(nullptr), remove_cv_t<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_null_pointer_v = is_null_pointer<_Ty>::value;

	namespace _impl {
		template<typename _Ty>
		struct _try_is_integral : false_type {};
		template<>
		struct _try_is_integral<bool> : true_type {};
		template<>
		struct _try_is_integral<char> : true_type {};
		template<>
		struct _try_is_integral<signed char> : true_type {};
		template<>
		struct _try_is_integral<unsigned char> : true_type {};
		template<>
		struct _try_is_integral<char8_t> : true_type {};
		template<>
		struct _try_is_integral<char16_t> : true_type {};
		template<>
		struct _try_is_integral<char32_t> : true_type {};
		template<>
		struct _try_is_integral<short> : true_type {};
		template<>
		struct _try_is_integral<unsigned short> : true_type {};
		template<>
		struct _try_is_integral<int> : true_type {};
		template<>
		struct _try_is_integral<unsigned int> : true_type {};
		template<>
		struct _try_is_integral<long> : true_type {};
		template<>
		struct _try_is_integral<unsigned long> : true_type {};
		template<>
		struct _try_is_integral<long long> : true_type {};
		template<>
		struct _try_is_integral<unsigned long long> : true_type {};
	}

	template<typename _Ty>
	struct is_integral : bool_constant<_impl::_try_is_integral<remove_cv_t<_Ty>>::value> {};
	template<typename _Ty>
	inline constexpr bool is_integral_v = is_integral<_Ty>::value;

	/* BUG(aki): This doesn't cover the fixed-size float types (float{16,32,64,128}_t) yet */
	namespace _impl {
		template<typename _Ty>
		struct _try_is_floating_point : false_type {};
		template<>
		struct _try_is_floating_point<float> : true_type {};
		template<>
		struct _try_is_floating_point<double> : true_type {};
		template<>
		struct _try_is_floating_point<long double> : true_type {};
	}
	template<typename _Ty>
	struct is_floating_point : bool_constant<_impl::_try_is_floating_point<remove_cv_t<_Ty>>::value> {};
	template<typename _Ty>
	inline constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;

	template<typename _Ty>
	struct is_array : false_type {};
	template<typename _Ty>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct is_array<_Ty[]> : true_type {};
	template<typename _Ty, std::size_t N>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct is_array<_Ty[N]> : true_type {};
	template<typename _Ty>
	inline constexpr bool is_array_v = is_array<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_enum : bool_constant<__is_enum(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_enum_v = is_enum<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_union : bool_constant<__is_union(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_union_v = is_union<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_class : bool_constant<__is_class(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_class_v = is_class<_Ty>::value;

#if __ABYSS_HAS_BUILTIN(__is_function)
	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_function : bool_constant<__is_function(_Ty)> {};
#else
	template<typename _Ty>
	struct is_function : bool_constant<!is_const_v<const _Ty>> {};
	template<typename _Ty>
	struct is_function<_Ty&> : false_type {};
#endif
	template<typename _Ty>
	inline constexpr bool is_function_v = is_function<_Ty>::value;

	namespace _impl {
		template<typename _Ty>
		struct _try_is_pointer : false_type {};
		template<typename _Ty>
		struct _try_is_pointer<_Ty*> : true_type {};
	}
	template<typename _Ty>
	struct is_pointer : bool_constant<_impl::_try_is_pointer<remove_cv_t<_Ty>>::value> {};
	template<typename _Ty>
	inline constexpr bool is_pointer_v = is_pointer<_Ty>::value;

	namespace _impl {
		template<typename _Ty>
		struct _try_is_lvalue_reference : false_type {};
		template<typename _Ty>
		struct _try_is_lvalue_reference<_Ty&> : true_type {};
	}
	template<typename _Ty>
	struct is_lvalue_reference : bool_constant<_impl::_try_is_lvalue_reference<remove_cv_t<_Ty>>::value> {};
	template<typename _Ty>
	inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;

	namespace _impl {
		template<typename _Ty>
		struct _try_is_rvalue_reference : false_type {};
		template<typename _Ty>
		struct _try_is_rvalue_reference<_Ty&&> : true_type {};
	}
	template<typename _Ty>
	struct is_rvalue_reference : bool_constant<_impl::_try_is_rvalue_reference<remove_cv_t<_Ty>>::value> {};
	template<typename _Ty>
	inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;

	template<typename _Ty>
	struct is_arithmetic : bool_constant<is_integral_v<_Ty> || is_floating_point_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;

	template<typename _Ty>
	struct is_fundamental : bool_constant<is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;

	namespace _impl {
		template<typename _Ty>
		struct _try_is_member_pointer : false_type {};
		template<typename _Ty, typename _Cl>
		struct _try_is_member_pointer<_Ty _Cl::*> : true_type {};
	}
	template<typename _Ty>
	struct is_member_pointer : bool_constant<_impl::_try_is_member_pointer<remove_cv_t<_Ty>>::value> {};
	template<typename _Ty>
	inline constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;

	namespace _impl {
		template<typename _Ty>
		struct _try_is_member_function_pointer : false_type {};
		template<typename _Ty, typename _Cl>
		struct _try_is_member_function_pointer<_Ty _Cl::*> : is_function<_Ty> {};
	}
	template<typename _Ty>
	struct is_member_function_pointer : bool_constant<_impl::_try_is_member_function_pointer<remove_cv_t<_Ty>>::value> {};
	template<typename _Ty>
	inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;

	template<typename _Ty>
	struct is_member_object_pointer : bool_constant<is_member_pointer_v<_Ty> && !is_member_function_pointer_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;

	template<typename _Ty>
	struct is_scalar : bool_constant<
		is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_null_pointer_v<_Ty> || is_member_pointer_v<_Ty>
	> {};
	template<typename _Ty>
	inline constexpr bool is_scalar_v = is_scalar<_Ty>::value;

	template<typename _Ty>
	struct is_object : bool_constant<is_scalar_v<_Ty> || is_array_v<_Ty> || is_union_v<_Ty> || is_class_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_object_v = is_object<_Ty>::value;

	template<typename _Ty>
	struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_compound_v = is_compound<_Ty>::value;

	template<typename _Ty>
	struct is_reference : bool_constant<is_lvalue_reference_v<_Ty> || is_rvalue_reference_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_reference_v = is_reference<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_trivial : bool_constant<__is_trivial(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_trivial_v = is_trivial<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_standard_layout_v = is_standard_layout<_Ty>::value;

	/* XXX(aki): `is_pod` is deprecated, and also relies on a GCC builtin */
	template<typename _Ty>
	struct is_pod : bool_constant<is_trivial_v<_Ty> && is_standard_layout_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_pod_v = is_pod<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_literal_type : bool_constant<__is_literal_type(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_literal_type_v = is_literal_type<_Ty>::value;


	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_empty : bool_constant<__is_empty(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_empty_v = is_empty<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_polymorphic_v = is_polymorphic<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_abstract : bool_constant<__is_abstract(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_abstract_v = is_abstract<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_final : bool_constant<__is_final(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_final_v = is_final<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_aggregate : bool_constant<__is_aggregate(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool is_aggregate_v = is_aggregate<_Ty>::value;

	namespace _impl {
		/* BUG(aki): This is to work around a bug in VSCodes syntax highlighting */
		template<typename _Ty>
		[[nodiscard]]
		constexpr bool _cmp_is_signed() noexcept {
			return _Ty(-1) < _Ty(0);
		}

		template<typename _Ty, bool = is_arithmetic_v<_Ty>>
		struct _try_is_signed : bool_constant<_cmp_is_signed<_Ty>()> {};
		template<typename _Ty>
		struct _try_is_signed<_Ty, false> : false_type {};
	}
	template<typename _Ty>
	struct is_signed : _impl::_try_is_signed<_Ty>::type {};
	template<typename _Ty>
	inline constexpr bool is_signed_v = is_signed<_Ty>::value;

	namespace _impl {
		/* BUG(aki): This is to work around a bug in VSCodes syntax highlighting */
		template<typename _Ty>
		[[nodiscard]]
		constexpr bool _cmp_is_unsigned() noexcept {
			return _Ty(0) < _Ty(-1);
		}

		template<typename _Ty, bool = is_arithmetic_v<_Ty>>
		struct _try_is_unsigned : bool_constant<_cmp_is_unsigned<_Ty>()> {};
		template<typename _Ty>
		struct _try_is_unsigned<_Ty, false> : false_type {};
	}
	template<typename _Ty>
	struct is_unsigned : _impl::_try_is_unsigned<_Ty>::type {};
	template<typename _Ty>
	inline constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;

	template<typename _Ty>
	struct is_bounded_array : false_type {};
	template<typename _Ty, std::size_t N>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct is_bounded_array<_Ty[N]> : true_type {};
	template<typename _Ty>
	inline constexpr bool is_bounded_array_v = is_bounded_array<_Ty>::value;

	template<typename _Ty>
	struct is_unbounded_array : false_type {};
	template<typename _Ty>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct is_unbounded_array<_Ty[]> : true_type {};
	template<typename _Ty>
	inline constexpr bool is_unbounded_array_v = is_unbounded_array<_Ty>::value;

#if __ABYSS_HAS_BUILTIN(__is_scoped_enum)
	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_scoped_enum : bool_constant<__is_scoped_enum(_Ty)> {};
#else
	template<typename _Ty>
	struct is_scoped_enum : false_type {};
	template<typename _Ty>
	requires is_enum_v<_Ty> && requires(remove_cv_t<_Ty> _type) { _type = _type; }
	struct is_scoped_enum<_Ty> : bool_constant<!requires(_Ty _type, void(*_f)(int)) {_f(_type); }> {};
#endif
	template<typename _Ty>
	inline constexpr bool is_scoped_enum_v = is_scoped_enum<_Ty>::value;

	namespace _impl {
		template<typename _Ty, std::size_t = sizeof(_Ty)>
		constexpr true_type _is_complete_or_unbounded(type_identity<_Ty>) { return {}; }
		template<typename _Ti, typename _Nt = _Ti::type>
		constexpr typename disjunction<is_reference<_Ti>, is_function<_Ti>, is_void<_Ti>, is_unbounded_array<_Ti>>::type
		_is_complete_or_unbounded(_Ti) { return {}; }
	}

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename... _Args>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {};
	template<typename _Ty, typename... _Args>
	inline constexpr bool is_constructible_v = is_constructible<_Ty, _Args...>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename... _Args>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {};
	template<typename _Ty, typename... _Args>
	inline constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Ty, _Args...>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename... _Args>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {};
	template<typename _Ty, typename... _Args>
	inline constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Ty, _Args...>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_default_constructible : bool_constant<is_constructible_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_default_constructible_v = is_default_constructible<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_trivially_default_constructible : bool_constant<is_trivially_constructible_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_nothrow_default_constructible : bool_constant<is_nothrow_constructible_v<_Ty>> {};
	template<typename _Ty>
	inline constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_copy_constructible : bool_constant<is_constructible_v<_Ty, add_lvalue_reference_t<const _Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_copy_constructible_v = is_copy_constructible<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_trivially_copy_constructible : bool_constant<is_trivially_constructible_v<_Ty, add_lvalue_reference_t<const _Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_nothrow_copy_constructible : bool_constant<is_nothrow_constructible_v<_Ty, add_lvalue_reference_t<const _Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_move_constructible : bool_constant<is_constructible_v<_Ty, add_rvalue_reference_t<_Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_move_constructible_v = is_move_constructible<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_trivially_move_constructible : bool_constant<is_trivially_constructible_v<_Ty, add_rvalue_reference_t<_Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_nothrow_move_constructible : bool_constant<is_nothrow_constructible_v<_Ty, add_rvalue_reference_t<_Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename _Uy>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_assignable : bool_constant<__is_assignable(_Ty, _Uy)> {};
	template<typename _Ty, typename _Uy>
	inline constexpr bool is_assignable_v = is_assignable<_Ty, _Uy>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename _Uy>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_Ty, _Uy)> {};
	template<typename _Ty, typename _Uy>
	inline constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Ty, _Uy>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename _Uy>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_Ty, _Uy)> {};
	template<typename _Ty, typename _Uy>
	inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Ty, _Uy>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_copy_assignable : bool_constant<is_assignable_v<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_trivially_copy_assignable : bool_constant<is_trivially_assignable_v<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_nothrow_copy_assignable : bool_constant<is_nothrow_assignable_v<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_move_assignable : bool_constant<is_assignable_v<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_move_assignable_v = is_move_assignable<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_trivially_move_assignable : bool_constant<is_trivially_assignable_v<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Ty>::value;

	template<typename _Ty>
	requires (_impl::_is_complete_or_unbounded(type_identity<_Ty>{}).value)
	struct is_nothrow_move_assignable : bool_constant<is_nothrow_assignable_v<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>> {};
	template<typename _Ty>
	inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {};
	template<typename _Ty>
	inline constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Ty>::value;


	/* TODO(aki): is_{,nothrow_}swappable_with */
	/* TODO(aki): is_{,nothrow_}swappable */

	template<typename _Ty>
	struct alignment_of : integral_constant<std::size_t , alignof(_Ty)> {};
	template<typename _Ty>
	inline constexpr std::size_t alignment_of_v = alignment_of<_Ty>::value;

	template<typename _Ty>
	struct rank : integral_constant<std::size_t, 0U> {};
	template<typename _Ty>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct rank<_Ty[]> : integral_constant<std::size_t, rank<_Ty>::value + 1U> {};
	template<typename _Ty, std::size_t N>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct rank<_Ty[N]> : integral_constant<std::size_t, rank<_Ty>::value + 1U> {};
	template<typename _Ty>
	inline constexpr std::size_t rank_v = rank<_Ty>::value;

	template<typename _Ty, unsigned N = 0U>
	struct extent : integral_constant<std::size_t, 0U> {};
	template<typename _Ty>
	struct extent<_Ty, 0U> : integral_constant<std::size_t, 0U> {};
	template<typename _Ty, unsigned N>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct extent<_Ty[], N> : extent<_Ty, N - 1U> {};
	template<typename _Ty, std::size_t I>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct extent<_Ty[I], 0U> : integral_constant<std::size_t, I> {};
	template<typename _Ty, std::size_t I, unsigned N>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct extent<_Ty[I], N> : extent<_Ty, N - 1U> {};
	template<typename _Ty, unsigned N = 0U>
	inline constexpr std::size_t extent_v = extent<_Ty, N>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename _Uy>
	struct is_base_of : bool_constant<__is_base_of(_Ty, _Uy)> {};
	template<typename _Ty, typename _Uy>
	inline constexpr bool is_base_of_v = is_base_of<_Ty, _Uy>::value;

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename _Uy>
	struct is_convertible : bool_constant<__is_convertible(_Ty, _Uy)> {};
	template<typename _Ty, typename _Uy>
	inline constexpr bool is_convertible_v = is_convertible<_Ty, _Uy>::value;

#if __ABYSS_HAS_BUILTIN(__is_nothrow_convertible)
	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename _Uy>
	struct is_nothrow_convertible : bool_constant<__is_nothrow_convertible(_Ty, _Uy)> {};
#else
	template<typename _Ty, typename _Uy>
	struct is_nothrow_convertible : conjunction<is_void<_Ty>, is_void<_Uy>> {};
	template<typename _Ty, typename _Uy>
	requires requires {
		static_cast<_Uy(*)()>(nullptr);
		{  _impl::declval<void(&)(_Uy) noexcept>()(_impl::declval<_Ty>()) } noexcept;
	} struct is_nothrow_convertible<_Ty, _Uy> : true_type {};
#endif
	template<typename _Ty, typename _Uy>
	inline constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_Ty, _Uy>::value;


	/* TODO(aki): is_layout_compatable */
	/* TODO(aki): is_pointer_interconvertible_base_of */
	/* TODO(aki): is_{,nothrow_}invocable{,_r} */

	namespace _impl {
		template<typename _Ty>
		struct _try_make_unsigned_match : type_identity<_Ty> {};
		template<>
		struct _try_make_unsigned_match<char> : type_identity<unsigned char> {};
		template<>
		struct _try_make_unsigned_match<signed char> : type_identity<unsigned char> {};
		template<>
		struct _try_make_unsigned_match<short> : type_identity<unsigned short> {};
		template<>
		struct _try_make_unsigned_match<int> : type_identity<unsigned int> {};
		template<>
		struct _try_make_unsigned_match<long> : type_identity<unsigned long> {};
		template<>
		struct _try_make_unsigned_match<long long> : type_identity<unsigned long long> {};

		template<typename _Ty, bool _Int = std::is_integral_v<_Ty>, bool _Enum = std::is_enum_v<_Ty>>
		struct _try_make_unsigned;
		template<typename _Ty>
		struct _try_make_unsigned<_Ty, true, false> : _match_cv<_Ty, typename _try_make_unsigned_match<std::remove_cv_t<_Ty>>::type> {};

		template<typename...>
		struct _size_pack {};
		template<typename _Ty, typename... _Ts>
		struct _size_pack<_Ty, _Ts...> : _size_pack<_Ts...> {
			static constexpr  std::size_t _size = sizeof(_Ty);
		};

		template<std::size_t _Size, typename _Ty, bool = (_Size <= _Ty::_size)>
		struct _size_filter;
		template<std::size_t _Size, typename _Ty, typename... _Ts>
		struct _size_filter<_Size, _size_pack<_Ty, _Ts...>, true> : std::type_identity<_Ty> {};
		template<std::size_t _Size, typename _Ty, typename... _Ts>
		struct _size_filter<_Size, _size_pack<_Ty, _Ts...>, false> :  _size_filter<_Size, _size_pack<_Ts...>>   {};


		template<typename _Ty>
		struct _try_make_unsigned<_Ty, false, true> :
			_match_cv<_Ty, typename _try_make_unsigned_match<
				typename _size_filter<sizeof(_Ty), _size_pack<
					unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long
				>>::type
			>::type>
		{};
		template<>
		struct _try_make_unsigned<wchar_t> : _try_make_unsigned<wchar_t, false, true> {};
		template<>
		struct _try_make_unsigned<char8_t> : _try_make_unsigned<char8_t, false, true> {};
	}

	template<typename _Ty>
	struct make_unsigned : _impl::_try_make_unsigned<_Ty> {};

	template<>
	struct make_unsigned<bool>;
	template<>
	struct make_unsigned<const bool>;
	template<>
	struct make_unsigned<volatile bool>;
	template<>
	struct make_unsigned<const volatile bool>;

	template<typename _Ty>
	using make_unsigned_t = make_unsigned<_Ty>::type;

	template<typename _Ty>
	struct remove_extent { using type = _Ty; };
	template<typename _Ty>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct remove_extent<_Ty[]> { using type = _Ty; };
	template<typename _Ty, std::size_t N>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct remove_extent<_Ty[N]> { using type = _Ty; };
	template<typename _Ty>
	using remove_extent_t = remove_extent<_Ty>::type;

	template<typename _Ty>
	struct remove_all_extents { using type = _Ty; };
	template<typename _Ty>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct remove_all_extents<_Ty[]> { using type = remove_all_extents<_Ty>::type; };
	template<typename _Ty, std::size_t N>
	// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
	struct remove_all_extents<_Ty[N]> { using type = remove_all_extents<_Ty>::type; };
	template<typename _Ty>
	using remove_all_extents_t = remove_all_extents<_Ty>::type;

	/* TODO(aki): This feels wrong, needs testing */
	namespace _impl {
		template<size_t _Len>
		struct _aligned_storage {
			[[gnu::aligned]]
			// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
			unsigned char _type[_Len];
		};
	}
	template<std::size_t Len, std::size_t Align = alignof(typename _impl::_aligned_storage<Len>::_type)>
	struct aligned_storage {
		// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
		struct type { alignas(Align) unsigned char data[Len]; };
	};
	template<std::size_t Len, std::size_t Align = alignof(typename _impl::_aligned_storage<Len>::_type)>
	using aligned_storage_t = aligned_storage<Len, Align>::type;

	/* TODO(aki): aligned_union */


	template<typename _Ty>
	struct decay {
	private:
		using _U = std::remove_reference_t<_Ty>;
	public:
		using type = std::conditional_t<
			std::is_array_v<_U>,
			std::add_pointer_t<std::remove_extent_t<_U>>,
			std::conditional_t<
				std::is_function_v<_U>,
				std::add_pointer_t<_U>,
				std::remove_cv_t<_U>
			>
		>;
	};
	template<typename _Ty>
	using decay_t = decay<_Ty>::type;


#if __ABYSS_HAS_BUILTIN(__is_destructible)
	template<typename _Ty>
	struct is_destructible : bool_constant<__is_destructible(_Ty)> {};
#else
	namespace _impl {
		template<typename _Ty, typename = decltype(_impl::declval<_Ty&>().~_Ty())>
		constexpr auto _try_is_destructible(int) -> true_type;
		template<typename>
		constexpr auto _try_is_destructible(...) -> false_type;

		template<
			typename _Ty,
			bool = (is_void_v<_Ty> || is_unbounded_array_v<_Ty> || is_function_v<_Ty>),
			bool = (is_reference_v<_Ty> || is_scalar_v<_Ty>)
		>
		struct _is_destructible;

		template<typename _Ty>
		struct _is_destructible<_Ty, false, false> : decltype(
			_impl::_try_is_destructible<remove_all_extents_t<_Ty>>(0)
		) {};

		template<typename _Ty>
		struct _is_destructible<_Ty, true, false> : false_type {};

		template<typename _Ty>
		struct _is_destructible<_Ty, false, true> : true_type {};
	}
	template<typename _Ty>
	struct is_destructible : _impl::_is_destructible<_Ty> {};

#endif
	template<typename _Ty>
	inline constexpr bool is_destructible_v = is_destructible<_Ty>::value;

#if __ABYSS_HAS_BUILTIN(__is_trivially_destructible)
	template<typename _Ty>
	struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {};
#else
	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct is_trivially_destructible : bool_constant<is_destructible_v<_Ty> && __has_trivial_destructor(_Ty)>  {};
#endif
	template<typename _Ty>
	inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Ty>::value;

#if __ABYSS_HAS_BUILTIN(__is_nothrow_destructible)
	template<typename _Ty>
	struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {};
#else
	namespace _impl {
		template<typename _Ty, bool = noexcept(_impl::declval<_Ty&>().~_Ty())>
		constexpr auto _try_is_nothrow_destructible(int) -> true_type;
		template<typename>
		constexpr auto _try_is_nothrow_destructible(...) -> false_type;

		template<
			typename _Ty,
			bool = (is_void_v<_Ty> || is_unbounded_array_v<_Ty> || is_function_v<_Ty>),
			bool = (is_reference_v<_Ty> || is_scalar_v<_Ty>)
		>
		struct _is_nothrow_destructible;

		template<typename _Ty>
		struct _is_nothrow_destructible<_Ty, false, false> : decltype(
			_impl::_try_is_nothrow_destructible<remove_all_extents_t<_Ty>>(0)
		) {};

		template<typename _Ty>
		struct _is_nothrow_destructible<_Ty, true, false> : false_type {};

		template<typename _Ty>
		struct _is_nothrow_destructible<_Ty, false, true> : true_type {};
	}
	template<typename _Ty>
	struct is_nothrow_destructible : _impl::_is_nothrow_destructible<_Ty> {};
#endif
	template<typename _Ty>
	inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Ty>::value;


	/* TODO(aki): common_type */
	/* TODO(aki): {,basic_}common_reference */

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, bool = is_enum_v<_Ty>>
	struct underlying_type : type_identity<__underlying_type(_Ty)> {};
	template<typename _Ty>
	struct underlying_type<_Ty, false> {};
	template<typename _Ty>
	using underlying_type_t = underlying_type<_Ty>::type;

	/* TODO(aki): result_of */
	/* TODO(aki): invoke_result */

	/* TODO(aki): unwrap_reference */
	/* TODO(aki): unwrap_ref_decay */

	/* NOTE(aki): Clang doesn't support the `__builtin_is_pointer_interconvertible_with_class`  */
	/*            and there is no way to implement it otherwise.                                */
#if __has_builtin(__builtin_is_pointer_interconvertible_with_class)
	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty, typename _M>
	[[nodiscard, gnu::always_inline]]
	constexpr bool is_pointer_interconvertible_with_class(_M _Ty::* _mp) noexcept {
		return __builtin_is_pointer_interconvertible_with_class(_mp);
	}
#endif

	/* NOTE(aki): Clang doesn't support the `__builtin_is_corresponding_member` and there is no */
	/*            way to implement it otherwise.                                                */
#if __has_builtin(__builtin_is_corresponding_member)
	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty1, typename _Ty2, typename _M1, typename _M2>
	[[nodiscard, gnu::always_inline]]
	constexpr bool is_corresponding_member(_M1 _Ty1::* _mp1, _M2 _Ty2::* _mp2) noexcept {
		return __builtin_is_corresponding_member(_mp1, _mp2);
	}
#endif

	/* XXX(aki): This relies on a GCC builtin  */
	[[nodiscard, gnu::always_inline]]
	constexpr bool is_constant_evaluated() noexcept {
		return __builtin_is_constant_evaluated();
	}

	/* XXX(aki): This relies on a GCC builtin  */
	template<typename _Ty>
	struct has_unique_object_representations : bool_constant<__has_unique_object_representations(
		remove_cv_t<remove_all_extents_t<_Ty>>
	)> {};
	template<typename _Ty>
	inline constexpr bool has_unique_object_representations_v = has_unique_object_representations<_Ty>::value;

}
// NOLINTEND(modernize-type-traits)
#endif /* ABYSS_TYPE_TRAITS */
/* vim: set ft=cpp ts=4 sw=4 noexpandtab: */
